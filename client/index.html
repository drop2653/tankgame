<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>íƒ‘ë·° ì „ì°¨ ì‹œë®¬ë ˆì´í„°</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:Inter,system-ui,Arial;}
  #ui {
    position: absolute; left:12px; top:12px; z-index: 30;
    background: rgba(0,0,0,0.35); padding:10px; border-radius:8px; backdrop-filter: blur(4px);
    min-width:240px;
  }
  #canvasWrap{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;}
  canvas{background:linear-gradient(#2b3,#123);border:3px solid #000;box-shadow:0 6px 30px rgba(0,0,0,0.7);}
  .hud-row{display:flex;gap:8px;align-items:center;margin-bottom:6px;}
  .bar{height:12px;background:rgba(255,255,255,0.08);border-radius:6px;overflow:hidden;flex:1}
  .bar-inner{height:100%;background:linear-gradient(90deg,#f44,#fa4);width:50%}
  .small{font-size:12px;color:#ddd}
  #controls{position:fixed; right:12px; bottom:12px; z-index:40; background:rgba(0,0,0,0.35); padding:10px;border-radius:8px;}
  #controls pre{margin:0;font-size:12px;line-height:1.4;color:#cfc}
  #minimap { position: absolute; right:12px; top:12px; width:200px; height:200px; background:rgba(0,0,0,0.5); border-radius:8px; padding:6px; display:none; z-index:50;}
</style>
</head>
<body>
<div id="ui">
  <div class="hud-row">
    <div style="width:120px">HP</div>
    <div class="bar"><div id="hpBar" class="bar-inner" style="width:100%"></div></div>
    <div id="hpText" class="small" style="min-width:48px;text-align:right">100%</div>
  </div>
  <div class="hud-row">
    <div style="width:120px">íƒ„ì¢…</div>
    <div id="ammoName" class="small">ì² ê°‘íƒ„ (1)</div>
  </div>
  <div class="hud-row">
    <div style="width:120px">ì¥ì „ ìƒíƒœ</div>
    <div class="small" id="reloadStatus">ë¹„ì¥ì „</div>
  </div>
  <div class="hud-row">
    <div style="width:120px">ë¨¸ì‹ ê±´ (W)</div>
    <div id="mgStatus" class="small">ì¤€ë¹„</div>
  </div>
  ë¯¸ë‹ˆë§µ: ëˆ„ë¥´ê³ ìˆê¸° Numpad8</div>
</div>

<div id="minimap"><canvas id="minimapCanvas" width="188" height="188"></canvas></div>

<div id="canvasWrap">
  <canvas id="game" width="1280" height="1280"></canvas>
</div>

<div id="controls">
  <pre>
    ì¡°ì‘ ì„¤ëª…
Q: ì¢Œì¸¡ ê¶¤ë„ ì „ì§„
E: ìš°ì¸¡ ê¶¤ë„ ì „ì§„
A: ì¢Œì¸¡ ê¶¤ë„ í›„ì§„
D: ìš°ì¸¡ ê¶¤ë„ í›„ì§„
W: ì°¨ì²´ ê¸°ê´€ì´
S: ì–‘ì¸¡ ê¶¤ë„ ë¸Œë ˆì´í¬
Z: ì¢Œì¸¡ ê¶¤ë„ ë¸Œë ˆì´í¬
C: ìš°ì¸¡ ê¶¤ë„ ë¸Œë ˆì´í¬
Num 4: í¬íƒ‘ ì—­ì‹œê³„ë°©í–¥ íšŒì „
Num 6: í¬íƒ‘ ì‹œê³„ë°©í–¥ íšŒì „
Num 5: í¬íƒ„ ì¥ì „
Num 1, 2, 3: í¬íƒ„ ì„ íƒ (ì² ê°‘íƒ„, ê³ ì†íƒ„, ì‘ì•½íƒ„)
Num 8: ë¯¸ë‹ˆë§µ í™•ì¸
Num 0: í¬ê²©
  </pre>
</div>

<script>

(() => {
  // ğŸ”Š ì‚¬ìš´ë“œ íŒŒì¼ ë¡œë“œ
const sounds = {
  fire: new Audio('fire.mp3'),
  reload: new Audio('reload.mp3'),
  mg: new Audio('shot.mp3')
};
Object.values(sounds).forEach(s => {
  s.volume = 0.5;
  s.loop = false;
});
sounds.reload.loop = true;

// ë¸Œë¼ìš°ì € ìë™ì¬ìƒ ë°©ì§€ íšŒí”¼ìš© â€” ìµœì´ˆ í´ë¦­ ì‹œ ì‚¬ìš´ë“œ í™œì„±í™”
window.addEventListener('click', () => {
  Object.values(sounds).forEach(s => s.play().then(()=>s.pause()).catch(()=>{}));
}, { once: true });
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const mmCanvas = document.getElementById('minimapCanvas');
  const mmCtx = mmCanvas.getContext('2d');
  const minimapEl = document.getElementById('minimap');

  const W = canvas.width, H = canvas.height;

  // State
  const tank = {
    x: W/2, y: H/2,
    angle: 0, // hull angle (radians)
    turretAngle: 0, // absolute angle (radians)
    speedLeft: 0, speedRight: 0,
    maxTrackSpeed: 50, // pixels/sec for full
    trackAccel: 220, // px/sec^2
    mass: 120, // for inertia effect (higher=slower responses)
    hp: 100,
  };
  
  const opponentTank = {
  x: 100,
  y: 100,
  angle: 0,
  turretAngle: 0,
  hp: 100,
    };

  function sendPlayerState() {
  if (!socket || socket.readyState !== WebSocket.OPEN) return;
  socket.send(JSON.stringify({
    type: "state",
    x: tank.x,
    y: tank.y,
    angle: tank.angle,
    turretAngle: tank.turretAngle,
    hp: tank.hp,
  }));
}

  const muzzleFlashes = [];

  // Camera / view
  let cameraAngle = 0; // radians
  let cameraX = 0, cameraY = 0; // we keep centered; can pan later

  // Keys
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.code]=true; e.preventDefault(); });
  window.addEventListener('keyup', (e)=>{ keys[e.code]=false; e.preventDefault(); });

  // Map & targets
  const map = { w: 2000, h: 1500 };
  const targets = [];
  for (let i=0;i<8;i++){
    targets.push({
      x: 200 + Math.random()*(map.w-400),
      y: 200 + Math.random()*(map.h-400),
      hp: 100,
      radius: 18 + Math.random()*14,
      id: i+1,
    });
  }

     socket = new WebSocket("wss://tank-server-5xys.onrender.com"); // ì‹¤ì œ ì„œë²„ ì£¼ì†Œë¡œ ë³€ê²½

socket.addEventListener('open', () => {
  console.log('ì„œë²„ ì—°ê²°ë¨');
  // í”Œë ˆì´ì–´ ì •ë³´ ì „ì†¡ (ì´ˆê¸°í™”)
  socket.send(JSON.stringify({ type: "join", id: Math.random().toString(36).slice(2) }));
});
  socket.addEventListener('message', (event) => {
  const msg = JSON.parse(event.data);

  if (msg.type === 'state') {
    opponentTank.x = msg.x;
    opponentTank.y = msg.y;
    opponentTank.angle = msg.angle;
    opponentTank.turretAngle = msg.turretAngle;
    opponentTank.hp = msg.hp;
  }

  if (msg.type === 'bullet') {
    bullets.push({
      x: msg.x,
      y: msg.y,
      vx: msg.vx,
      vy: msg.vy,
      life: 6,
      dmg: msg.dmg,
      r: msg.r,
      explosive: msg.explosive,
      splash: msg.splash || 0,
      splashRadius: msg.splashRadius || 0,
      type: msg.bulletType,
      from: 'opponent'
    });
}
});

  // Ammo types
  const AMMOS = {
    AP: { name:'ì² ê°‘íƒ„(AP)', speed:700, damage:40, radius:4, explosive:false },
    FAST: { name:'ê³ ì†íƒ„', speed:1100, damage:30, radius:3, explosive:false },
    HE: { name:'ì‘ì•½íƒ„(HE)', speed:550, damage:28, radius:10, explosive:true, splash:40, splashRadius:60 },
  };

  let selectedAmmoKey = 'AP';
  let turretLoaded = false;
  let reloadTimer = 0; // when >0, loading
  const RELOAD_TIME = 7.0; // seconds

  // Projectiles
  const bullets = [];
  const mgBursts = []; // for machinegun bullets (simple)

  // Machine gun
  let mgCooldown = 0;
  const MG_RPM = 400; // rounds per minute approximate
  const MG_INTERVAL = 60/MG_RPM; // seconds per round

  // Time
  let last = performance.now();

  // Utility
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function toRad(deg){ return deg*Math.PI/180; }
  function toDeg(rad){ return rad*180/Math.PI; }
  function angleTo(a,b){ let d = b - a; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; return d; }

  // ì‚¬ìš©ì í‚¤ ë§¤í•‘ (ìš”ì²­ì— ë§ì¶¤)
  const keyMap = {
      leftBrake: 'KeyC',   // â¬… ì¢Œì¸¡ ê¶¤ë„ ë¸Œë ˆì´í¬
  rightBrake: 'KeyZ',  // â¡ ìš°ì¸¡ ê¶¤ë„ ë¸Œë ˆì´í¬
    leftTrackForward: 'KeyQ',   // q
    rightTrackForward: 'KeyE',  // e
    leftTrackBack: 'KeyA',      // a
    rightTrackBack: 'KeyD',     // d
    brake: 'KeyS',              // s
    machineGun: 'KeyW',         // w

    turretLeft: 'Numpad4',
    turretRight: 'Numpad6',
    turretLoad: 'Numpad5', // start reload
    fire: 'Numpad0',

    select1: 'Digit1', select2: 'Digit2', select3: 'Digit3',
    nselect1: 'Numpad1', nselect2: 'Numpad2', nselect3: 'Numpad3',

    camLeft: 'Numpad7',
    camRight: 'Numpad9',
    minimapHold: 'Numpad8'
  };

  // Accept both Numpad and top-row digits for ammo
  function checkAmmoSelect(){
    if (keys[keyMap.select1] || keys[keyMap.nselect1]) { selectedAmmoKey='AP'; turretLoaded=false; reloadTimer=0; }
    if (keys[keyMap.select2] || keys[keyMap.nselect2]) { selectedAmmoKey='FAST'; turretLoaded=false; reloadTimer=0; }
    if (keys[keyMap.select3] || keys[keyMap.nselect3]) { selectedAmmoKey='HE'; turretLoaded=false; reloadTimer=0; }
  }

  // Movement logic: convert track inputs to angular & linear velocity
  function updateMovement(dt){
    // target speeds from keys: -1/0/1
    let leftTarget=0, rightTarget=0;
    if (keys[keyMap.leftTrackForward]) leftTarget = 1;
    if (keys[keyMap.leftTrackBack]) leftTarget = -1;
    if (keys[keyMap.rightTrackForward]) rightTarget = 1;
    if (keys[keyMap.rightTrackBack]) rightTarget = -1;
    

    // ---- ëŠë¦° ê°€ì†(Ramp) ì„¤ì • ----
    // rampTime: ëª©í‘œ(Â±1)ê¹Œì§€ ë„ë‹¬í•˜ëŠ”ë° ê±¸ë¦¬ëŠ” ì´ˆ (ì—¬ê¸°ì„œ 6.0ì´ˆë¡œ ê¸¸ê²Œ ì„¤ì •)
    const rampTime = 6.0; // í•„ìš”í•˜ë©´ 8.0, 10.0 ë“±ìœ¼ë¡œ ë” ê¸¸ê²Œ
    // frame fraction: ì´ í”„ë ˆì„ì—ì„œ ëª©í‘œì¹˜ ìª½ìœ¼ë¡œ ì–¼ë§ˆë‚˜ ì´ë™í• ì§€ ë¹„ìœ¨
    const frac = dt / Math.max(0.0001, rampTime);

    // ë¶€ë“œëŸ½ê²Œ ë³´ì • (exponential-like smoothing)
    tank.speedLeft  += (leftTarget  - tank.speedLeft)  * frac;
    tank.speedRight += (rightTarget - tank.speedRight) * frac;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ê°œë³„ ê¶¤ë„ ë¸Œë ˆì´í¬ (ì¢Œ Z / ìš° C / ì „ì²´ S)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const brakeFrac = Math.min(1, dt * 8.0);

if (keys[keyMap.leftBrake]) {
  tank.speedLeft += (0 - tank.speedLeft) * brakeFrac;
}
if (keys[keyMap.rightBrake]) {
  tank.speedRight += (0 - tank.speedRight) * brakeFrac;
}
if (keys[keyMap.brake]) { // Sí‚¤ ì „ì²´ ë¸Œë ˆì´í¬
  tank.speedLeft  += (0 - tank.speedLeft)  * brakeFrac;
  tank.speedRight += (0 - tank.speedRight) * brakeFrac;
}

    // Convert differential tracks to motion:
    // forward speed = average * maxTrackSpeed
    const forward = (tank.speedLeft + tank.speedRight)/2 * tank.maxTrackSpeed;
    // rotation rate = difference * factor
    const rotRate = (tank.speedRight - tank.speedLeft) * 1.2; // rad/sec scale

    // update position with simple physics
    const dx = Math.cos(tank.angle) * forward * dt;
    const dy = Math.sin(tank.angle) * forward * dt;
    tank.x += dx;
    tank.y += dy;
    tank.angle += rotRate * dt * 1.2; // tweak for nice feel

    // clamp within map
    tank.x = clamp(tank.x, 20, map.w-20);
    tank.y = clamp(tank.y, 20, map.h-20);
  }

  // turret rotate
  function updateTurret(dt){
    const turretSpeed = toRad(18); // deg/sec
    if (keys[keyMap.turretLeft]) tank.turretAngle -= turretSpeed*dt;
    if (keys[keyMap.turretRight]) tank.turretAngle += turretSpeed*dt;
    // turret angle independent; keep within -PI..PI
    while (tank.turretAngle > Math.PI) tank.turretAngle -= Math.PI*2;
    while (tank.turretAngle < -Math.PI) tank.turretAngle += Math.PI*2;
    // optional: turret slowly returns towards hull when idle? skipped for realism
  }

  // camera control
  function updateCamera(dt){
    // show minimap while Numpad8 held
    minimapEl.style.display = keys[keyMap.minimapHold] ? 'block' : 'none';
  }

  // reload handling
  function updateReload(dt){
    if (reloadTimer > 0){
      if (sounds.reload.paused) {
      sounds.reload.currentTime = 0;
      sounds.reload.play();
    }

    reloadTimer -= dt;
    if (reloadTimer <= 0){
      reloadTimer = 0;
      turretLoaded = true;

      // âœ… ì¥ì „ ì™„ë£Œ â†’ ë£¨í”„ ì¤‘ì§€
      sounds.reload.pause();
      sounds.reload.currentTime = 0;
    }
    }
  }

  // Machine gun
  function updateMG(dt){
    if (mgCooldown > 0) mgCooldown = Math.max(0, mgCooldown - dt);
    if (keys[keyMap.machineGun] && mgCooldown === 0){
      mgCooldown = MG_INTERVAL;
      sounds.mg.currentTime = 0;
    sounds.mg.play();
      // spawn a machinegun bullet
      const px = tank.x + Math.cos(tank.angle)*34;
      const py = tank.y + Math.sin(tank.angle)*34;
      bullets.push({ x: px, y: py, vx: Math.cos(tank.angle)*1200, vy: Math.sin(tank.angle)*1200,
        life: 1.2, dmg: 0.5, r:2, from:'mg' });
    }
  }

  // fire turret shell
 function tryFireTurret(){
  if (!turretLoaded) return; // ì¥ì „ ì•ˆ ë˜ì–´ ìˆìœ¼ë©´ ì•„ë¬´ ë°˜ì‘ X
  turretLoaded = false;

  // âœ… ì‹¤ì œ ë°œì‚¬ ì‹œì ì—ë§Œ ì‚¬ìš´ë“œ ì¬ìƒ
  sounds.fire.currentTime = 0;
  sounds.fire.play();
    // create projectile with AMMO properties
    const info = AMMOS[selectedAmmoKey];
    const speed = info.speed;
    const px = tank.x + Math.cos(tank.turretAngle)*36;
    const py = tank.y + Math.sin(tank.turretAngle)*36;
    bullets.push({
      x: px, y: py,
      vx: Math.cos(tank.turretAngle)*speed,
      vy: Math.sin(tank.turretAngle)*speed,
      life: 6,
      dmg: info.damage,
      r: info.radius,
      explosive: info.explosive,
      splash: info.splash || 0,
      splashRadius: info.splashRadius || 0,
      type: selectedAmmoKey
    });

   muzzleFlashes.push({
  x: px,
  y: py,
  r: info.radius * 3,
  life: 0.2,
  alpha: 1.0
});

    if (socket.readyState === WebSocket.OPEN) {
  socket.send(JSON.stringify({
    type: "bullet",
    x: px,
    y: py,
    vx: Math.cos(tank.turretAngle)*speed,
    vy: Math.sin(tank.turretAngle)*speed,
    dmg: info.damage,
    r: info.radius,
    explosive: info.explosive,
    splash: info.splash || 0,
    splashRadius: info.splashRadius || 0,
    bulletType: selectedAmmoKey

  }));
        }
}
  function updateMuzzle(dt) {
  for (let i = muzzleFlashes.length - 1; i >= 0; i--) {
    const m = muzzleFlashes[i];
    m.life -= dt;
    m.alpha = m.life / 0.2;
    if (m.life <= 0) muzzleFlashes.splice(i, 1);
  }
}

function updateBullets(dt){
  for (let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.life -= dt;
    if (b.life <= 0 || b.x < -50 || b.x > map.w+50 || b.y < -50 || b.y > map.h+50){
      bullets.splice(i,1);
      continue;
    }
    // ì¶©ëŒ ì²˜ë¦¬
    for (let j=targets.length-1;j>=0;j--){
      const t = targets[j];
      const dx = b.x - t.x, dy = b.y - t.y;
      const dist = Math.hypot(dx,dy);
      if (dist < (b.r + t.radius)){
        if (b.explosive){
          for (let k=0;k<targets.length;k++){
            const tt = targets[k];
            const d2 = Math.hypot(b.x-tt.x,b.y-tt.y);
            if (d2 <= b.splashRadius){
              const ratio = 1 - d2 / b.splashRadius;
              const dmg = Math.round((b.splash) * ratio);
              tt.hp -= dmg;
            }
          }
        } else {
          t.hp -= b.dmg;
        }
        bullets.splice(i,1);
        break;
      }
          const dx2 = b.x - opponentTank.x;
const dy2 = b.y - opponentTank.y;
const dist2 = Math.hypot(dx2, dy2);

if (dist2 < 30 && b.from !== 'opponent') {
  if (b.explosive) {
    // ìŠ¤í”Œë˜ì‹œ ë°ë¯¸ì§€ ì ìš© (ë‹¨ìˆœí™”)
    const ratio = 1 - dist2 / (b.splashRadius || 60);
    const splashDmg = Math.round((b.splash || 0) * ratio);
    opponentTank.hp -= splashDmg;
  } else {
    opponentTank.hp -= b.dmg;
  }
  bullets.splice(i, 1);
  continue;
}
    }
  }
  // ì£½ì€ íƒ€ê²Ÿ ì œê±°
  for (let i=targets.length-1;i>=0;i--){
    if (targets[i].hp <= 0) targets.splice(i,1);
  }
}

  // Drawing
  function worldToScreen(x,y){
    // world coordinates to canvas coords with camera centered on tank and rotated by cameraAngle
    const cx = canvas.width/2;
    const cy = canvas.height/2;
    const dx = x - tank.x;
    const dy = y - tank.y;
    // rotate by -cameraAngle (camera rotates view)
    const cosa = Math.cos(-cameraAngle), sina = Math.sin(-cameraAngle);
    const rx = dx*cosa - dy*sina;
    const ry = dx*sina + dy*cosa;
    return { x: cx + rx, y: cy + ry };
  }
      function drawOpponentTank(ctx, worldToScreen) {
  const pos = worldToScreen(opponentTank.x, opponentTank.y);

  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(opponentTank.angle);

  // ì°¨ì²´
  ctx.fillStyle = '#a55';
  ctx.fillRect(-28, -18, 56, 36);

  // ê¶¤ë„
  ctx.fillStyle = '#333';
  ctx.fillRect(-28, -26, 56, 8);
  ctx.fillRect(-28, 18, 56, 8);
  ctx.restore();

  // í¬íƒ‘
  ctx.save();
  ctx.translate(pos.x, pos.y);
  ctx.rotate(opponentTank.turretAngle);
  ctx.fillStyle = '#a33';
  ctx.fillRect(0, -3, 42, 6);
  ctx.restore();

  // HP ë°”
  ctx.fillStyle = '#f00';
  ctx.fillRect(pos.x - 20, pos.y - 40, 40, 6);
  ctx.fillStyle = '#0f0';
  ctx.fillRect(pos.x - 20, pos.y - 40, 40 * (opponentTank.hp / 100), 6);
}

  function draw(){

    // clear
    ctx.fillStyle = '#263'; ctx.fillRect(0,0,W,H);

    // draw grid for map (simple)
    ctx.save();
    // translate so that tank is at center, then rotate by camera
    ctx.translate(W/2, H/2);
    ctx.rotate(cameraAngle);
    ctx.translate(-tank.x, -tank.y);

    // background ground
    const tile = 120;
    ctx.fillStyle = 'rgba(45,60,40,0.8)';
    ctx.fillRect(tank.x - W/2 - 200, tank.y - H/2 - 200, W + 400, H + 400);

    // draw some scenery (rocks / boxes)
    ctx.fillStyle = '#4a3';
    for (let gx = 0; gx < map.w; gx += 300){
      for (let gy = 0; gy < map.h; gy += 300){
        ctx.beginPath();
        ctx.ellipse(gx+30, gy+20, 26, 14, 0, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // draw targets
    for (const t of targets){
      ctx.save();
      ctx.translate(t.x, t.y);
      // target body
      ctx.fillStyle = 'rgba(180,40,40,0.95)';
      ctx.beginPath();
      ctx.arc(0,0,t.radius,0,Math.PI*2);
      ctx.fill();
      // hp bar
      const hpPerc = Math.max(0,t.hp)/100;
      ctx.fillStyle = '#222'; ctx.fillRect(-t.radius, -t.radius-10, t.radius*2, 6);
      ctx.fillStyle = '#4f4'; ctx.fillRect(-t.radius, -t.radius-10, t.radius*2 * Math.max(0,Math.min(1,t.hp/100)), 6);
      ctx.restore();
    }
    for (const m of muzzleFlashes){
  ctx.save();
  ctx.globalAlpha = m.alpha;
  ctx.fillStyle = 'rgba(255,230,150,1)';
  ctx.beginPath();
  ctx.arc(m.x, m.y, m.r, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

    // draw bullets
    for (const b of bullets){
      ctx.fillStyle = (b.type === 'HE') ? 'orange' : (b.from==='mg' ? '#ffd' : '#ccc');
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      // simple trail
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.beginPath();
      ctx.moveTo(b.x - b.vx*0.03, b.y - b.vy*0.03);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }

    // draw tank hull
    ctx.save();
    ctx.translate(tank.x, tank.y);
    ctx.rotate(tank.angle);
    // hull body
    ctx.fillStyle = '#3a5';
    ctx.fillRect(-28, -18, 56, 36);
    // tracks
ctx.fillStyle = '#222';
ctx.fillRect(-28, -26, 56, 8);  // ìœ„ìª½ ê¶¤ë„
ctx.fillRect(-28, 18, 56, 8); 
    // turret base
    ctx.fillStyle = '#476';
    ctx.beginPath();
    ctx.ellipse(0,0,20,18,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // draw turret (independent rotation) - in world coords
    ctx.save();
    ctx.translate(tank.x, tank.y);
    ctx.rotate(tank.turretAngle);
    // turret barrel
    ctx.fillStyle = '#2b3';
    ctx.fillRect(0, -3, 42, 6);
    // turret ring
    ctx.fillStyle = '#394';
    ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();

    drawOpponentTank(ctx, worldToScreen);
    
    ctx.restore();

    ctx.strokeStyle = 'red';
ctx.lineWidth = 4;
ctx.strokeRect(0, 0, map.w, map.h);

    ctx.restore(); // end of camera transforms

    // draw crosshair direction (fixed alignment with turret)
ctx.save();
ctx.translate(canvas.width / 2, canvas.height / 2);
ctx.rotate(tank.turretAngle - cameraAngle); // í¬íƒ‘ ê°ë„ì—ì„œ ì¹´ë©”ë¼ íšŒì „ê°’ ë³´ì •
ctx.strokeStyle = 'rgba(255,255,255,0.25)';
ctx.beginPath();
ctx.moveTo(0, 0);
ctx.lineTo(60, 0); // í¬íƒ‘ ì •ë©´ ë°©í–¥ìœ¼ë¡œ ì„ 
ctx.stroke();
ctx.restore();

// Draw reload progress bar (ìœ„ìª½ ê²Œì´ì§€)
if (reloadTimer > 0) {
  const progress = 1 - (reloadTimer / RELOAD_TIME);
  const barWidth = 300;
  const barHeight = 12;
  const x = (canvas.width - barWidth) / 2;
  const y = 30;

  // ë°°ê²½
  ctx.fillStyle = "rgba(255,255,255,0.15)";
  ctx.fillRect(x, y, barWidth, barHeight);

  // ì§„í–‰ ë¶€ë¶„
  ctx.fillStyle = "lime";
  ctx.fillRect(x, y, barWidth * progress, barHeight);

  // í…Œë‘ë¦¬
  ctx.strokeStyle = "rgba(255,255,255,0.4)";
  ctx.strokeRect(x, y, barWidth, barHeight);
}

    // HUD: draw simple cross/aim reticle at center
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, 28, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(canvas.width/2 - 6, canvas.height/2); ctx.lineTo(canvas.width/2 + 6, canvas.height/2);
    ctx.moveTo(canvas.width/2, canvas.height/2 - 6); ctx.lineTo(canvas.width/2, canvas.height/2 + 6);
    ctx.stroke();

    // draw small text info
    ctx.fillStyle = '#fff';
    ctx.font = '12px sans-serif';
    ctx.fillText('ìœ„ì¹˜: ' + Math.round(tank.x) + ',' + Math.round(tank.y), 12, H - 12);
    ctx.fillText('í¬íƒ‘ ì•µê¸€: ' + Math.round(toDeg(tank.turretAngle)) + 'Â°', 160, H - 12);
  }

  // Draw minimapssss
  function drawMinimap(){
  mmCtx.clearRect(0, 0, mmCanvas.width, mmCanvas.height);
  mmCtx.fillStyle = '#041';
  mmCtx.fillRect(0, 0, mmCanvas.width, mmCanvas.height);

  // map scale
  const pad = 6;
  const sx = (mmCanvas.width - 2 * pad) / map.w;
  const sy = (mmCanvas.height - 2 * pad) / map.h;
  const s = Math.min(sx, sy);

  // draw targets
  for (const t of targets){
    mmCtx.fillStyle = '#f55';
    mmCtx.beginPath();
    mmCtx.arc(pad + t.x * s, pad + t.y * s, Math.max(2, t.radius * s), 0, Math.PI * 2);
    mmCtx.fill();
  }

  // draw player tank (green)
  mmCtx.save();
  mmCtx.translate(pad + tank.x * s, pad + tank.y * s);
  mmCtx.rotate(tank.angle - cameraAngle);
  mmCtx.fillStyle = '#6f6';
  mmCtx.fillRect(-6, -4, 12, 8);
  mmCtx.restore();

  // âœ… draw opponent tank (red)
  mmCtx.save();
  mmCtx.translate(pad + opponentTank.x * s, pad + opponentTank.y * s);
  mmCtx.rotate(opponentTank.angle - cameraAngle);
  mmCtx.fillStyle = '#f44';
  mmCtx.fillRect(-6, -4, 12, 8);
  mmCtx.restore();
}

  // UI updates
  const hpBar = document.getElementById('hpBar');
  const hpText = document.getElementById('hpText');
  const ammoNameEl = document.getElementById('ammoName');
  const reloadStatusEl = document.getElementById('reloadStatus');
  const mgStatusEl = document.getElementById('mgStatus');

  function updateUI(dt){
    hpBar.style.width = (tank.hp/100*100) + '%';
    hpText.textContent = Math.max(0, Math.round(tank.hp)) + '%';
    ammoNameEl.textContent = AMMOS[selectedAmmoKey].name + ' (' + (selectedAmmoKey==='AP'?'1': selectedAmmoKey==='FAST'?'2':'3') + ')';
    if (reloadTimer > 0) {
      reloadStatusEl.textContent = 'ì¥ì „ì¤‘: ' + reloadTimer.toFixed(1) + 's';
    } else if (turretLoaded) {
      reloadStatusEl.textContent = 'ì™„ë£Œ (ë°œì‚¬ ëŒ€ê¸°)';
    } else {
      reloadStatusEl.textContent = 'ë¹„ì¥ì „ (Numpad5ë¡œ ì¥ì „)';
    }
    if (mgCooldown > 0) mgStatusEl.textContent = 'ì¬ì¥ì „ ëŒ€ê¸°: ' + mgCooldown.toFixed(2) + 's';
    else mgStatusEl.textContent = 'ì¤€ë¹„';
  }

  // Controls: pressing Numpad5 starts reload (7s)
  window.addEventListener('keydown', (e)=>{
    // avoid repeating when key is held (use .code check)
    if (e.code === keyMap.turretLoad && reloadTimer <= 0 && !turretLoaded){
      reloadTimer = RELOAD_TIME;
      sounds.reload.currentTime = 0;
  sounds.reload.play();
    }
    if (e.code === keyMap.fire){
      // spacebar fired
      tryFireTurret();
    }
    // ammo selection via either digit or numpad digits handled each frame
  });

  // Very simple AI: targets slowly move randomly (optional)
  function updateTargets(dt){
    for (const t of targets){
      t.x += (Math.sin(t.id + performance.now()*0.0002) * 10) * dt;
      t.y += (Math.cos(t.id + performance.now()*0.00017) * 8) * dt;
      t.x = clamp(t.x, 10, map.w-10);
      t.y = clamp(t.y, 10, map.h-10);
    }
  }

  // Main loop
  function frame(now){
    const dt = Math.min(0.04, (now - last) / 1000);
    last = now;

    updateMuzzle(dt);
    updateBullets(dt);
    checkAmmoSelect();
    updateMovement(dt);
    updateTurret(dt);
    updateCamera(dt);
    updateReload(dt);
    updateMG(dt);
    updateTargets(dt);
    sendPlayerState();

    updateUI(dt);
    draw();
    drawMinimap();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Instructions: click canvas to focus
  canvas.addEventListener('click', ()=>canvas.focus());

  // helpful: allow WASD alternative for tracks? (not requested) - not added to keep faithful

  // initial message in console for debugging
  console.log('íƒ‘ë·° ì „ì°¨ ì‹œë®¬ë ˆì´í„° ë¡œë“œë¨ â€” í‚¤ë¥¼ ëˆŒëŸ¬ ì¡°ì‘í•˜ì„¸ìš”.');

})();
</script>
</body>
</html>





